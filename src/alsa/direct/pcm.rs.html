<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/alsa-0.5.0/src/direct/pcm.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>pcm.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../alsa/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../alsa/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../alsa/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
</pre><pre class="rust"><code><span class="doccomment">/*!
This module bypasses alsa-lib and directly read and write into memory mapped kernel memory.
In case of the sample memory, this is in many cases the DMA buffers that is transferred to the sound card.

The reasons for doing this are:

 * Minimum overhead where it matters most: let alsa-lib do the code heavy setup -
   then steal its file descriptor and deal with sample streaming from Rust.
 * RT-safety to the maximum extent possible. Creating/dropping any of these structs causes syscalls,
   but function calls on these are just read and write from memory. No syscalls, no memory allocations,
   not even loops (with the exception of `MmapPlayback::write` that loops over samples to write).
 * Possibility to allow Send + Sync for structs
 * It&#39;s a fun experiment and an interesting deep dive into how alsa-lib does things.

Note: Not all sound card drivers support this direct method of communication; although almost all
modern/common ones do. It only works with hardware devices though (such as &quot;hw:xxx&quot; device strings),
don&#39;t expect it to work with, e g, the PulseAudio plugin or so.

For an example of how to use this mode, look in the &quot;synth-example&quot; directory.
*/</span>

<span class="kw">use</span> <span class="ident">libc</span>;
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">mem</span>, <span class="ident">ptr</span>, <span class="ident">fmt</span>, <span class="ident">cmp</span>};
<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::error</span>::{<span class="ident">Error</span>, <span class="prelude-ty">Result</span>};
<span class="kw">use</span> <span class="ident">std::os::unix::io::RawFd</span>;
<span class="kw">use</span> <span class="kw">crate</span>::{<span class="ident">pcm</span>, <span class="ident">PollDescriptors</span>, <span class="ident">Direction</span>};
<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::pcm::Frames</span>;
<span class="kw">use</span> <span class="ident">std::marker::PhantomData</span>;

<span class="kw">use</span> <span class="ident"><span class="kw">super</span>::ffi</span>::<span class="kw-2">*</span>;

<span class="doccomment">/// Read PCM status via a simple kernel syscall, bypassing alsa-lib.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// If Status is not available on your architecture, this is the second best option.</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SyncPtrStatus</span>(<span class="ident">snd_pcm_mmap_status</span>);

<span class="kw">impl</span> <span class="ident">SyncPtrStatus</span> {
    <span class="doccomment">/// Executes sync_ptr syscall.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Unsafe because</span>
    <span class="doccomment">///  - setting appl_ptr and avail_min might make alsa-lib confused</span>
    <span class="doccomment">///  - no check that the fd is really a PCM</span>
    <span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">sync_ptr</span>(<span class="ident">fd</span>: <span class="ident">RawFd</span>, <span class="ident">hwsync</span>: <span class="ident">bool</span>, <span class="ident">appl_ptr</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">pcm::Frames</span><span class="op">&gt;</span>, <span class="ident">avail_min</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">pcm::Frames</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">snd_pcm_sync_ptr</span> {
			<span class="ident">flags</span>: (<span class="kw">if</span> <span class="ident">hwsync</span> { <span class="ident">SNDRV_PCM_SYNC_PTR_HWSYNC</span> } <span class="kw">else</span> { <span class="number">0</span> }) <span class="op">+</span>
				(<span class="kw">if</span> <span class="ident">appl_ptr</span>.<span class="ident">is_some</span>() { <span class="ident">SNDRV_PCM_SYNC_PTR_APPL</span> } <span class="kw">else</span> { <span class="number">0</span> }) <span class="op">+</span>
				(<span class="kw">if</span> <span class="ident">avail_min</span>.<span class="ident">is_some</span>() { <span class="ident">SNDRV_PCM_SYNC_PTR_AVAIL_MIN</span> } <span class="kw">else</span> { <span class="number">0</span> }),
			<span class="ident">c</span>: <span class="ident">snd_pcm_mmap_control_r</span> {
				<span class="ident">control</span>: <span class="ident">snd_pcm_mmap_control</span> {
					<span class="ident">appl_ptr</span>: <span class="ident">appl_ptr</span>.<span class="ident">unwrap_or</span>(<span class="number">0</span>) <span class="kw">as</span> <span class="ident">snd_pcm_uframes_t</span>,
					<span class="ident">avail_min</span>: <span class="ident">avail_min</span>.<span class="ident">unwrap_or</span>(<span class="number">0</span>) <span class="kw">as</span> <span class="ident">snd_pcm_uframes_t</span>,
				}
			},
			<span class="ident">s</span>: <span class="ident">mem::zeroed</span>()
		};

        <span class="ident">sndrv_pcm_ioctl_sync_ptr</span>(<span class="ident">fd</span>, <span class="kw-2">&amp;mut</span> <span class="ident">data</span>).<span class="ident">map_err</span>(<span class="op">|</span><span class="kw">_</span><span class="op">|</span>
            <span class="ident">Error::new</span>(<span class="string">&quot;SNDRV_PCM_IOCTL_SYNC_PTR&quot;</span>, <span class="ident">nix::errno::Errno::last</span>() <span class="kw">as</span> <span class="ident">i32</span>))<span class="question-mark">?</span>;

        <span class="kw">let</span> <span class="ident">i</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">s</span>.<span class="ident">status</span>.<span class="ident">state</span>;
        <span class="kw">if</span> (<span class="ident">i</span> <span class="op">&gt;</span><span class="op">=</span> (<span class="ident">pcm::State::Open</span> <span class="kw">as</span> <span class="ident">snd_pcm_state_t</span>)) <span class="op">&amp;&amp;</span> (<span class="ident">i</span> <span class="op">&lt;</span><span class="op">=</span> (<span class="ident">pcm::State::Disconnected</span> <span class="kw">as</span> <span class="ident">snd_pcm_state_t</span>)) {
            <span class="prelude-val">Ok</span>(<span class="ident">SyncPtrStatus</span>(<span class="ident">data</span>.<span class="ident">s</span>.<span class="ident">status</span>))
        } <span class="kw">else</span> {
            <span class="prelude-val">Err</span>(<span class="ident">Error::unsupported</span>(<span class="string">&quot;SNDRV_PCM_IOCTL_SYNC_PTR returned broken state&quot;</span>))
        }
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hw_ptr</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">pcm::Frames</span> { <span class="self">self</span>.<span class="number">0</span>.<span class="ident">hw_ptr</span> <span class="kw">as</span> <span class="ident">pcm::Frames</span> }
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">state</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">pcm::State</span> { <span class="kw">unsafe</span> { <span class="ident">mem::transmute</span>(<span class="self">self</span>.<span class="number">0</span>.<span class="ident">state</span> <span class="kw">as</span> <span class="ident">u8</span>) } <span class="comment">/* valid range checked in sync_ptr */</span> }
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">htstamp</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">libc::timespec</span> { <span class="self">self</span>.<span class="number">0</span>.<span class="ident">tstamp</span> }
}



<span class="doccomment">/// Read PCM status directly from memory, bypassing alsa-lib.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This means that it&#39;s</span>
<span class="doccomment">/// 1) less overhead for reading status (no syscall, no allocations, no virtual dispatch, just a read from memory)</span>
<span class="doccomment">/// 2) Send + Sync, and</span>
<span class="doccomment">/// 3) will only work for &quot;hw&quot; / &quot;plughw&quot; devices (not e g PulseAudio plugins), and not</span>
<span class="doccomment">/// all of those are supported, although all common ones are (as of 2017, and a kernel from the same decade).</span>
<span class="doccomment">/// Kernel supported archs are: x86, PowerPC, Alpha. Use &quot;SyncPtrStatus&quot; for other archs.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The values are updated every now and then by the kernel. Many functions will force an update to happen,</span>
<span class="doccomment">/// e g `PCM::avail()` and `PCM::delay()`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Note: Even if you close the original PCM device, ALSA will not actually close the device until all</span>
<span class="doccomment">/// Status structs are dropped too.</span>
<span class="doccomment">///</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Status</span>(<span class="ident">DriverMemory</span><span class="op">&lt;</span><span class="ident">snd_pcm_mmap_status</span><span class="op">&gt;</span>);

<span class="kw">fn</span> <span class="ident">pcm_to_fd</span>(<span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="ident">pcm::PCM</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">RawFd</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fds</span>: [<span class="ident">libc::pollfd</span>; <span class="number">1</span>] <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">mem::zeroed</span>() };
    <span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">PollDescriptors::fill</span>(<span class="ident">p</span>, <span class="kw-2">&amp;mut</span> <span class="ident">fds</span>)<span class="question-mark">?</span>;
    <span class="kw">if</span> <span class="ident">c</span> <span class="op">!</span><span class="op">=</span> <span class="number">1</span> {
        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">Error::unsupported</span>(<span class="string">&quot;snd_pcm_poll_descriptors returned wrong number of fds&quot;</span>))
    }
    <span class="prelude-val">Ok</span>(<span class="ident">fds</span>[<span class="number">0</span>].<span class="ident">fd</span>)
}

<span class="kw">impl</span> <span class="ident">Status</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="ident">pcm::PCM</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> { <span class="ident">Status::from_fd</span>(<span class="ident">pcm_to_fd</span>(<span class="ident">p</span>)<span class="question-mark">?</span>) }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from_fd</span>(<span class="ident">fd</span>: <span class="ident">RawFd</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="ident">DriverMemory::new</span>(<span class="ident">fd</span>, <span class="number">1</span>, <span class="ident">SNDRV_PCM_MMAP_OFFSET_STATUS</span> <span class="kw">as</span> <span class="ident">libc::off_t</span>, <span class="bool-val">false</span>).<span class="ident">map</span>(<span class="op">|</span><span class="ident">d</span><span class="op">|</span> <span class="ident">Status</span>(<span class="ident">d</span>))
    }

    <span class="doccomment">/// Current PCM state.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">state</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">pcm::State</span> {
        <span class="kw">unsafe</span> {
            <span class="kw">let</span> <span class="ident">i</span> <span class="op">=</span> <span class="ident">ptr::read_volatile</span>(<span class="kw-2">&amp;</span>(<span class="kw-2">*</span><span class="self">self</span>.<span class="number">0</span>.<span class="ident">ptr</span>).<span class="ident">state</span>);
            <span class="macro">assert!</span>((<span class="ident">i</span> <span class="op">&gt;</span><span class="op">=</span> (<span class="ident">pcm::State::Open</span> <span class="kw">as</span> <span class="ident">snd_pcm_state_t</span>)) <span class="op">&amp;&amp;</span> (<span class="ident">i</span> <span class="op">&lt;</span><span class="op">=</span> (<span class="ident">pcm::State::Disconnected</span> <span class="kw">as</span> <span class="ident">snd_pcm_state_t</span>)));
            <span class="ident">mem::transmute</span>(<span class="ident">i</span> <span class="kw">as</span> <span class="ident">u8</span>)
        }
    }

    <span class="doccomment">/// Number of frames hardware has read or written</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This number is updated every now and then by the kernel.</span>
    <span class="doccomment">/// Calling most functions on the PCM will update it, so will usually a period interrupt.</span>
    <span class="doccomment">/// No guarantees given.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This value wraps at &quot;boundary&quot; (a large value you can read from SwParams).</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hw_ptr</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">pcm::Frames</span> {
        <span class="kw">unsafe</span> {
            <span class="ident">ptr::read_volatile</span>(<span class="kw-2">&amp;</span>(<span class="kw-2">*</span><span class="self">self</span>.<span class="number">0</span>.<span class="ident">ptr</span>).<span class="ident">hw_ptr</span>) <span class="kw">as</span> <span class="ident">pcm::Frames</span>
        }
    }

    <span class="doccomment">/// Timestamp - fast version of alsa-lib&#39;s Status::get_htstamp</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Note: This just reads the actual value in memory.</span>
    <span class="doccomment">/// Unfortunately, the timespec is too big to be read atomically on most archs.</span>
    <span class="doccomment">/// Therefore, this function can potentially give bogus result at times, at least in theory...?</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">htstamp</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">libc::timespec</span> {
        <span class="kw">unsafe</span> {
            <span class="ident">ptr::read_volatile</span>(<span class="kw-2">&amp;</span>(<span class="kw-2">*</span><span class="self">self</span>.<span class="number">0</span>.<span class="ident">ptr</span>).<span class="ident">tstamp</span>)
        }
    }

    <span class="doccomment">/// Audio timestamp - fast version of alsa-lib&#39;s Status::get_audio_htstamp</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Note: This just reads the actual value in memory.</span>
    <span class="doccomment">/// Unfortunately, the timespec is too big to be read atomically on most archs.</span>
    <span class="doccomment">/// Therefore, this function can potentially give bogus result at times, at least in theory...?</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">audio_htstamp</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">libc::timespec</span> {
        <span class="kw">unsafe</span> {
            <span class="ident">ptr::read_volatile</span>(<span class="kw-2">&amp;</span>(<span class="kw-2">*</span><span class="self">self</span>.<span class="number">0</span>.<span class="ident">ptr</span>).<span class="ident">audio_tstamp</span>)
        }
    }
}

<span class="doccomment">/// Write PCM appl ptr directly, bypassing alsa-lib.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Provides direct access to appl ptr and avail min, without the overhead of</span>
<span class="doccomment">/// alsa-lib or a syscall. Caveats that apply to Status applies to this struct too.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Control</span>(<span class="ident">DriverMemory</span><span class="op">&lt;</span><span class="ident">snd_pcm_mmap_control</span><span class="op">&gt;</span>);

<span class="kw">impl</span> <span class="ident">Control</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="ident">pcm::PCM</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> { <span class="ident"><span class="self">Self</span>::from_fd</span>(<span class="ident">pcm_to_fd</span>(<span class="ident">p</span>)<span class="question-mark">?</span>) }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from_fd</span>(<span class="ident">fd</span>: <span class="ident">RawFd</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="ident">DriverMemory::new</span>(<span class="ident">fd</span>, <span class="number">1</span>, <span class="ident">SNDRV_PCM_MMAP_OFFSET_CONTROL</span> <span class="kw">as</span> <span class="ident">libc::off_t</span>, <span class="bool-val">true</span>).<span class="ident">map</span>(<span class="op">|</span><span class="ident">d</span><span class="op">|</span> <span class="ident">Control</span>(<span class="ident">d</span>))
    }

    <span class="doccomment">/// Read number of frames application has read or written</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This value wraps at &quot;boundary&quot; (a large value you can read from SwParams).</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">appl_ptr</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">pcm::Frames</span> {
        <span class="kw">unsafe</span> {
            <span class="ident">ptr::read_volatile</span>(<span class="kw-2">&amp;</span>(<span class="kw-2">*</span><span class="self">self</span>.<span class="number">0</span>.<span class="ident">ptr</span>).<span class="ident">appl_ptr</span>) <span class="kw">as</span> <span class="ident">pcm::Frames</span>
        }
    }

    <span class="doccomment">/// Set number of frames application has read or written</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// When the kernel wakes up due to a period interrupt, this value will</span>
    <span class="doccomment">/// be checked by the kernel. An XRUN will happen in case the application</span>
    <span class="doccomment">/// has not read or written enough data.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_appl_ptr</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">value</span>: <span class="ident">pcm::Frames</span>) {
        <span class="kw">unsafe</span> {
            <span class="ident">ptr::write_volatile</span>(<span class="kw-2">&amp;mut</span> (<span class="kw-2">*</span><span class="self">self</span>.<span class="number">0</span>.<span class="ident">ptr</span>).<span class="ident">appl_ptr</span>, <span class="ident">value</span> <span class="kw">as</span> <span class="ident">snd_pcm_uframes_t</span>)
        }
    }

    <span class="doccomment">/// Read minimum number of frames in buffer in order to wakeup process</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">avail_min</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">pcm::Frames</span> {
        <span class="kw">unsafe</span> {
            <span class="ident">ptr::read_volatile</span>(<span class="kw-2">&amp;</span>(<span class="kw-2">*</span><span class="self">self</span>.<span class="number">0</span>.<span class="ident">ptr</span>).<span class="ident">avail_min</span>) <span class="kw">as</span> <span class="ident">pcm::Frames</span>
        }
    }

    <span class="doccomment">/// Write minimum number of frames in buffer in order to wakeup process</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_avail_min</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">value</span>: <span class="ident">pcm::Frames</span>) {
        <span class="kw">unsafe</span> {
            <span class="ident">ptr::write_volatile</span>(<span class="kw-2">&amp;mut</span> (<span class="kw-2">*</span><span class="self">self</span>.<span class="number">0</span>.<span class="ident">ptr</span>).<span class="ident">avail_min</span>, <span class="ident">value</span> <span class="kw">as</span> <span class="ident">snd_pcm_uframes_t</span>)
        }
    }
}

<span class="kw">struct</span> <span class="ident">DriverMemory</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> {
   <span class="ident">ptr</span>: <span class="kw-2">*mut</span> <span class="ident">S</span>,
   <span class="ident">size</span>: <span class="ident">libc::size_t</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> <span class="ident">fmt::Debug</span> <span class="kw">for</span> <span class="ident">DriverMemory</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> {
   <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;mut</span> <span class="ident">fmt::Formatter</span>) -&gt; <span class="ident">fmt::Result</span> { <span class="macro">write!</span>(<span class="ident">f</span>, <span class="string">&quot;DriverMemory({:?})&quot;</span>, <span class="self">self</span>.<span class="ident">ptr</span>) }
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> <span class="ident">DriverMemory</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">fd</span>: <span class="ident">RawFd</span>, <span class="ident">count</span>: <span class="ident">usize</span>, <span class="ident">offs</span>: <span class="ident">libc::off_t</span>, <span class="ident">writable</span>: <span class="ident">bool</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">total</span> <span class="op">=</span> <span class="ident">count</span> <span class="op">*</span> <span class="ident">mem::size_of</span>::<span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>();
        <span class="kw">let</span> <span class="ident">ps</span> <span class="op">=</span> <span class="ident">pagesize</span>();
        <span class="macro">assert!</span>(<span class="ident">total</span> <span class="op">&gt;</span> <span class="number">0</span>);
        <span class="kw">if</span> <span class="ident">total</span> <span class="op">%</span> <span class="ident">ps</span> <span class="op">!</span><span class="op">=</span> <span class="number">0</span> { <span class="ident">total</span> <span class="op">+</span><span class="op">=</span> <span class="ident">ps</span> <span class="op">-</span> <span class="ident">total</span> <span class="op">%</span> <span class="ident">ps</span> };
        <span class="kw">let</span> <span class="ident">flags</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">writable</span> { <span class="ident">libc::PROT_WRITE</span> <span class="op">|</span> <span class="ident">libc::PROT_READ</span> } <span class="kw">else</span> { <span class="ident">libc::PROT_READ</span> };
        <span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">libc::mmap</span>(<span class="ident">ptr::null_mut</span>(), <span class="ident">total</span>, <span class="ident">flags</span>, <span class="ident">libc::MAP_FILE</span> <span class="op">|</span> <span class="ident">libc::MAP_SHARED</span>, <span class="ident">fd</span>, <span class="ident">offs</span>) };
        <span class="kw">if</span> <span class="ident">p</span> <span class="op">==</span> <span class="ident">ptr::null_mut</span>() <span class="op">|</span><span class="op">|</span> <span class="ident">p</span> <span class="op">==</span> <span class="ident">libc::MAP_FAILED</span> {
            <span class="prelude-val">Err</span>(<span class="ident">Error::new</span>(<span class="string">&quot;mmap (of driver memory)&quot;</span>, <span class="ident">nix::errno::Errno::last</span>() <span class="kw">as</span> <span class="ident">i32</span>))
        } <span class="kw">else</span> {
            <span class="prelude-val">Ok</span>(<span class="ident">DriverMemory</span> { <span class="ident">ptr</span>: <span class="ident">p</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">S</span>, <span class="ident">size</span>: <span class="ident">total</span> })
        }
    }
}

<span class="kw">unsafe</span> <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> <span class="ident">Send</span> <span class="kw">for</span> <span class="ident">DriverMemory</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> {}
<span class="kw">unsafe</span> <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> <span class="ident">Sync</span> <span class="kw">for</span> <span class="ident">DriverMemory</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> {}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> <span class="ident">Drop</span> <span class="kw">for</span> <span class="ident">DriverMemory</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">drop</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) {
        <span class="kw">unsafe</span> {{ <span class="ident">libc::munmap</span>(<span class="self">self</span>.<span class="ident">ptr</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">libc::c_void</span>, <span class="self">self</span>.<span class="ident">size</span>); } }
    }
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">SampleData</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> {
    <span class="ident">mem</span>: <span class="ident">DriverMemory</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>,
    <span class="ident">frames</span>: <span class="ident">pcm::Frames</span>,
    <span class="ident">channels</span>: <span class="ident">u32</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> <span class="ident">SampleData</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="ident">pcm::PCM</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">params</span> <span class="op">=</span> <span class="ident">p</span>.<span class="ident">hw_params_current</span>()<span class="question-mark">?</span>;
        <span class="kw">let</span> <span class="ident">bufsize</span> <span class="op">=</span> <span class="ident">params</span>.<span class="ident">get_buffer_size</span>()<span class="question-mark">?</span>;
        <span class="kw">let</span> <span class="ident">channels</span> <span class="op">=</span> <span class="ident">params</span>.<span class="ident">get_channels</span>()<span class="question-mark">?</span>;
        <span class="kw">if</span> <span class="ident">params</span>.<span class="ident">get_access</span>()<span class="question-mark">?</span> <span class="op">!</span><span class="op">=</span> <span class="ident">pcm::Access::MMapInterleaved</span> {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">Error::unsupported</span>(<span class="string">&quot;Not MMAP interleaved data&quot;</span>))
        }

        <span class="kw">let</span> <span class="ident">fd</span> <span class="op">=</span> <span class="ident">pcm_to_fd</span>(<span class="ident">p</span>)<span class="question-mark">?</span>;
        <span class="kw">let</span> <span class="ident">info</span> <span class="op">=</span> <span class="kw">unsafe</span> {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">info</span>: <span class="ident">snd_pcm_channel_info</span> <span class="op">=</span> <span class="ident">mem::zeroed</span>();
            <span class="ident">sndrv_pcm_ioctl_channel_info</span>(<span class="ident">fd</span>, <span class="kw-2">&amp;mut</span> <span class="ident">info</span>).<span class="ident">map_err</span>(<span class="op">|</span><span class="kw">_</span><span class="op">|</span>
                <span class="ident">Error::new</span>(<span class="string">&quot;SNDRV_PCM_IOCTL_CHANNEL_INFO&quot;</span>, <span class="ident">nix::errno::Errno::last</span>() <span class="kw">as</span> <span class="ident">i32</span>))<span class="question-mark">?</span>;
            <span class="ident">info</span>
        };
        <span class="comment">// println!(&quot;{:?}&quot;, info);</span>
        <span class="kw">if</span> (<span class="ident">info</span>.<span class="ident">step</span> <span class="op">!</span><span class="op">=</span> <span class="ident">channels</span> <span class="op">*</span> <span class="ident">mem::size_of</span>::<span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>() <span class="kw">as</span> <span class="ident">u32</span> <span class="op">*</span> <span class="number">8</span>) <span class="op">|</span><span class="op">|</span> (<span class="ident">info</span>.<span class="ident">first</span> <span class="op">!</span><span class="op">=</span> <span class="number">0</span>) {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">Error::unsupported</span>(<span class="string">&quot;MMAP data size mismatch&quot;</span>))
        }
        <span class="prelude-val">Ok</span>(<span class="ident">SampleData</span> {
            <span class="ident">mem</span>: <span class="ident">DriverMemory::new</span>(<span class="ident">fd</span>, (<span class="ident">bufsize</span> <span class="kw">as</span> <span class="ident">usize</span>) <span class="op">*</span> (<span class="ident">channels</span> <span class="kw">as</span> <span class="ident">usize</span>), <span class="ident">info</span>.<span class="ident">offset</span> <span class="kw">as</span> <span class="ident">libc::off_t</span>, <span class="bool-val">true</span>)<span class="question-mark">?</span>,
            <span class="ident">frames</span>: <span class="ident">bufsize</span>,
            <span class="ident">channels</span>: <span class="ident">channels</span>,
        })
    }
}


<span class="doccomment">/// Dummy trait for better generics</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">MmapDir</span>: <span class="ident">fmt::Debug</span> {
    <span class="kw">const</span> <span class="ident">DIR</span>: <span class="ident">Direction</span>;
    <span class="kw">fn</span> <span class="ident">avail</span>(<span class="ident">hwptr</span>: <span class="ident">Frames</span>, <span class="ident">applptr</span>: <span class="ident">Frames</span>, <span class="ident">buffersize</span>: <span class="ident">Frames</span>, <span class="ident">boundary</span>: <span class="ident">Frames</span>) -&gt; <span class="ident">Frames</span>;
}

<span class="doccomment">/// Dummy struct for better generics</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Playback</span>;

<span class="kw">impl</span> <span class="ident">MmapDir</span> <span class="kw">for</span> <span class="ident">Playback</span> {
    <span class="kw">const</span> <span class="ident">DIR</span>: <span class="ident">Direction</span> <span class="op">=</span> <span class="ident">Direction::Playback</span>;
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">avail</span>(<span class="ident">hwptr</span>: <span class="ident">Frames</span>, <span class="ident">applptr</span>: <span class="ident">Frames</span>, <span class="ident">buffersize</span>: <span class="ident">Frames</span>, <span class="ident">boundary</span>: <span class="ident">Frames</span>) -&gt; <span class="ident">Frames</span> {
	<span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="ident">hwptr</span>.<span class="ident">wrapping_add</span>(<span class="ident">buffersize</span>).<span class="ident">wrapping_sub</span>(<span class="ident">applptr</span>);
	<span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">r</span> <span class="op">&lt;</span> <span class="number">0</span> { <span class="ident">r</span>.<span class="ident">wrapping_add</span>(<span class="ident">boundary</span>) } <span class="kw">else</span> { <span class="ident">r</span> };
        <span class="kw">if</span> <span class="ident">r</span> <span class="kw">as</span> <span class="ident">usize</span> <span class="op">&gt;</span><span class="op">=</span> <span class="ident">boundary</span> <span class="kw">as</span> <span class="ident">usize</span> { <span class="ident">r</span>.<span class="ident">wrapping_sub</span>(<span class="ident">boundary</span>) } <span class="kw">else</span> { <span class="ident">r</span> }
    }
}

<span class="doccomment">/// Dummy struct for better generics</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Capture</span>;

<span class="kw">impl</span> <span class="ident">MmapDir</span> <span class="kw">for</span> <span class="ident">Capture</span> {
    <span class="kw">const</span> <span class="ident">DIR</span>: <span class="ident">Direction</span> <span class="op">=</span> <span class="ident">Direction::Capture</span>;
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">avail</span>(<span class="ident">hwptr</span>: <span class="ident">Frames</span>, <span class="ident">applptr</span>: <span class="ident">Frames</span>, <span class="ident">_buffersize</span>: <span class="ident">Frames</span>, <span class="ident">boundary</span>: <span class="ident">Frames</span>) -&gt; <span class="ident">Frames</span> {
	<span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="ident">hwptr</span>.<span class="ident">wrapping_sub</span>(<span class="ident">applptr</span>);
	<span class="kw">if</span> <span class="ident">r</span> <span class="op">&lt;</span> <span class="number">0</span> { <span class="ident">r</span>.<span class="ident">wrapping_add</span>(<span class="ident">boundary</span>) } <span class="kw">else</span> { <span class="ident">r</span> }
    }
}

<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">MmapPlayback</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">MmapIO</span><span class="op">&lt;</span><span class="ident">S</span>, <span class="ident">Playback</span><span class="op">&gt;</span>;

<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">MmapCapture</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">MmapIO</span><span class="op">&lt;</span><span class="ident">S</span>, <span class="ident">Capture</span><span class="op">&gt;</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="doccomment">/// Struct containing direct I/O functions shared between playback and capture.</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">MmapIO</span><span class="op">&lt;</span><span class="ident">S</span>, <span class="ident">D</span><span class="op">&gt;</span> {
    <span class="ident">data</span>: <span class="ident">SampleData</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>,
    <span class="ident">c</span>: <span class="ident">Control</span>,
    <span class="ident">ss</span>: <span class="ident">Status</span>,
    <span class="ident">bound</span>: <span class="ident">Frames</span>,
    <span class="ident">dir</span>: <span class="ident">PhantomData</span><span class="op">&lt;</span><span class="kw-2">*const</span> <span class="ident">D</span><span class="op">&gt;</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Clone</span>, <span class="ident">Copy</span>)]</span>
<span class="doccomment">/// A raw pointer to samples, and the amount of samples readable or writable.</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RawSamples</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> {
    <span class="kw">pub</span> <span class="ident">ptr</span>: <span class="kw-2">*mut</span> <span class="ident">S</span>,
    <span class="kw">pub</span> <span class="ident">frames</span>: <span class="ident">Frames</span>,
    <span class="kw">pub</span> <span class="ident">channels</span>: <span class="ident">u32</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> <span class="ident">RawSamples</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="doccomment">/// Returns `frames` * `channels`, i e the amount of samples (of type `S`) that can be read/written.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">samples</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">isize</span> { <span class="self">self</span>.<span class="ident">frames</span> <span class="kw">as</span> <span class="ident">isize</span> <span class="op">*</span> (<span class="self">self</span>.<span class="ident">channels</span> <span class="kw">as</span> <span class="ident">isize</span>) }

    <span class="doccomment">/// Writes samples from an iterator.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Returns true if iterator was depleted, and the number of samples written.</span>
    <span class="doccomment">/// This is just raw read/write of memory.</span>
    <span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">write_samples</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">S</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">i</span>: <span class="kw-2">&amp;mut</span> <span class="ident">I</span>) -&gt; (<span class="ident">bool</span>, <span class="ident">isize</span>) {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">z</span> <span class="op">=</span> <span class="number">0</span>;
        <span class="kw">let</span> <span class="ident">max_samples</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">samples</span>();
        <span class="kw">while</span> <span class="ident">z</span> <span class="op">&lt;</span> <span class="ident">max_samples</span> {
            <span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">b</span>) <span class="op">=</span> <span class="ident">i</span>.<span class="ident">next</span>() { <span class="ident">b</span> } <span class="kw">else</span> { <span class="kw">return</span> (<span class="bool-val">true</span>, <span class="ident">z</span>) };
            <span class="ident">ptr::write_volatile</span>(<span class="self">self</span>.<span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="ident">z</span>), <span class="ident">b</span>);
            <span class="ident">z</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        };
        (<span class="bool-val">false</span>, <span class="ident">z</span>)
    }

}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">S</span>, <span class="ident">D</span>: <span class="ident">MmapDir</span><span class="op">&gt;</span> <span class="ident">MmapIO</span><span class="op">&lt;</span><span class="ident">S</span>, <span class="ident">D</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="ident">pcm::PCM</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="ident">p</span>.<span class="ident">info</span>()<span class="question-mark">?</span>.<span class="ident">get_stream</span>() <span class="op">!</span><span class="op">=</span> <span class="ident">D::DIR</span> {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">Error::unsupported</span>(<span class="string">&quot;Wrong direction&quot;</span>));
        }
        <span class="kw">let</span> <span class="ident">boundary</span> <span class="op">=</span> <span class="ident">p</span>.<span class="ident">sw_params_current</span>()<span class="question-mark">?</span>.<span class="ident">get_boundary</span>()<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(<span class="ident">MmapIO</span> {
            <span class="ident">data</span>: <span class="ident">SampleData::new</span>(<span class="ident">p</span>)<span class="question-mark">?</span>,
            <span class="ident">c</span>: <span class="ident">Control::new</span>(<span class="ident">p</span>)<span class="question-mark">?</span>,
            <span class="ident">ss</span>: <span class="ident">Status::new</span>(<span class="ident">p</span>)<span class="question-mark">?</span>,
            <span class="ident">bound</span>: <span class="ident">boundary</span>,
            <span class="ident">dir</span>: <span class="ident">PhantomData</span>,
        })
    }
}

<span class="kw">pub</span> (<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">new_mmap</span><span class="op">&lt;</span><span class="ident">S</span>, <span class="ident">D</span>: <span class="ident">MmapDir</span><span class="op">&gt;</span>(<span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="ident">pcm::PCM</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">MmapIO</span><span class="op">&lt;</span><span class="ident">S</span>, <span class="ident">D</span><span class="op">&gt;</span><span class="op">&gt;</span> { <span class="ident">MmapIO::new</span>(<span class="ident">p</span>) }

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">S</span>, <span class="ident">D</span>: <span class="ident">MmapDir</span><span class="op">&gt;</span> <span class="ident">MmapIO</span><span class="op">&lt;</span><span class="ident">S</span>, <span class="ident">D</span><span class="op">&gt;</span> {
    <span class="doccomment">/// Read current status</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">status</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="ident">Status</span> { <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">ss</span> }

    <span class="doccomment">/// Read current number of frames committed by application</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This number wraps at &#39;boundary&#39;.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">appl_ptr</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">Frames</span> { <span class="self">self</span>.<span class="ident">c</span>.<span class="ident">appl_ptr</span>() }

    <span class="doccomment">/// Read current number of frames read / written by hardware</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This number wraps at &#39;boundary&#39;.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hw_ptr</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">Frames</span> { <span class="self">self</span>.<span class="ident">ss</span>.<span class="ident">hw_ptr</span>() }

    <span class="doccomment">/// The number at which hw_ptr and appl_ptr wraps.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">boundary</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">Frames</span> { <span class="self">self</span>.<span class="ident">bound</span> }

    <span class="doccomment">/// Total number of frames in hardware buffer</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">buffer_size</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">Frames</span> { <span class="self">self</span>.<span class="ident">data</span>.<span class="ident">frames</span> }

    <span class="doccomment">/// Number of channels in stream</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">channels</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">u32</span> { <span class="self">self</span>.<span class="ident">data</span>.<span class="ident">channels</span> }

    <span class="doccomment">/// Notifies the kernel that frames have now been read / written by the application</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This will allow the kernel to write new data into this part of the buffer.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">commit</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">v</span>: <span class="ident">Frames</span>) {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">z</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">appl_ptr</span>() <span class="op">+</span> <span class="ident">v</span>;
        <span class="kw">if</span> <span class="ident">z</span> <span class="op">+</span> <span class="ident">v</span> <span class="op">&gt;</span><span class="op">=</span> <span class="self">self</span>.<span class="ident">boundary</span>() { <span class="ident">z</span> <span class="op">-</span><span class="op">=</span> <span class="self">self</span>.<span class="ident">boundary</span>() };
        <span class="self">self</span>.<span class="ident">c</span>.<span class="ident">set_appl_ptr</span>(<span class="ident">z</span>)
    }

    <span class="doccomment">/// Number of frames available to read / write.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// In case of an underrun, this value might be bigger than the buffer size.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">avail</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">Frames</span> { <span class="ident">D::avail</span>(<span class="self">self</span>.<span class="ident">hw_ptr</span>(), <span class="self">self</span>.<span class="ident">appl_ptr</span>(), <span class="self">self</span>.<span class="ident">buffer_size</span>(), <span class="self">self</span>.<span class="ident">boundary</span>()) }

    <span class="doccomment">/// Returns raw pointers to data to read / write.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Use this if you want to read/write data yourself (instead of using iterators). If you do,</span>
    <span class="doccomment">/// using `write_volatile` or `read_volatile` is recommended, since it&#39;s DMA memory and can</span>
    <span class="doccomment">/// change at any time.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Since this is a ring buffer, there might be more data to read/write in the beginning</span>
    <span class="doccomment">/// of the buffer as well. If so this is returned as the second return value.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">data_ptr</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; (<span class="ident">RawSamples</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>, <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">RawSamples</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span><span class="op">&gt;</span>) {
        <span class="kw">let</span> (<span class="ident">hwptr</span>, <span class="ident">applptr</span>) <span class="op">=</span> (<span class="self">self</span>.<span class="ident">hw_ptr</span>(), <span class="self">self</span>.<span class="ident">appl_ptr</span>());
        <span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">channels</span>();
        <span class="kw">let</span> <span class="ident">bufsize</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">buffer_size</span>();

        <span class="comment">// These formulas mostly mimic the behaviour of</span>
        <span class="comment">// snd_pcm_mmap_begin (in alsa-lib/src/pcm/pcm.c).</span>
        <span class="kw">let</span> <span class="ident">offs</span> <span class="op">=</span> <span class="ident">applptr</span> <span class="op">%</span> <span class="ident">bufsize</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">D::avail</span>(<span class="ident">hwptr</span>, <span class="ident">applptr</span>, <span class="ident">bufsize</span>, <span class="self">self</span>.<span class="ident">boundary</span>());
        <span class="ident">a</span> <span class="op">=</span> <span class="ident">cmp::min</span>(<span class="ident">a</span>, <span class="ident">bufsize</span>);
        <span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">bufsize</span> <span class="op">-</span> <span class="ident">offs</span>;
        <span class="kw">let</span> <span class="ident">more_data</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">b</span> <span class="op">&lt;</span> <span class="ident">a</span> {
            <span class="kw">let</span> <span class="ident">z</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">-</span> <span class="ident">b</span>;
            <span class="ident">a</span> <span class="op">=</span> <span class="ident">b</span>;
            <span class="prelude-val">Some</span>( <span class="ident">RawSamples</span> { <span class="ident">ptr</span>: <span class="self">self</span>.<span class="ident">data</span>.<span class="ident">mem</span>.<span class="ident">ptr</span>, <span class="ident">frames</span>: <span class="ident">z</span>, <span class="ident">channels</span>: <span class="ident">c</span> })
        } <span class="kw">else</span> { <span class="prelude-val">None</span> };

        <span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="self">self</span>.<span class="ident">data</span>.<span class="ident">mem</span>.<span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="ident">offs</span> <span class="kw">as</span> <span class="ident">isize</span> <span class="op">*</span> <span class="self">self</span>.<span class="ident">data</span>.<span class="ident">channels</span> <span class="kw">as</span> <span class="ident">isize</span>) };
        (<span class="ident">RawSamples</span> { <span class="ident">ptr</span>: <span class="ident">p</span>, <span class="ident">frames</span>: <span class="ident">a</span>, <span class="ident">channels</span>: <span class="ident">c</span> }, <span class="ident">more_data</span>)
    }
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> <span class="ident">MmapPlayback</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> {
    <span class="doccomment">/// Write samples to the kernel ringbuffer.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">write</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">S</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">i</span>: <span class="kw-2">&amp;mut</span> <span class="ident">I</span>) -&gt; <span class="ident">Frames</span> {
        <span class="kw">let</span> (<span class="ident">data</span>, <span class="ident">more_data</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">data_ptr</span>();
        <span class="kw">let</span> (<span class="ident">iter_end</span>, <span class="ident">samples</span>) <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">data</span>.<span class="ident">write_samples</span>(<span class="ident">i</span>) };
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">z</span> <span class="op">=</span> <span class="ident">samples</span> <span class="op">/</span> <span class="ident">data</span>.<span class="ident">channels</span> <span class="kw">as</span> <span class="ident">isize</span>;
        <span class="kw">if</span> <span class="op">!</span><span class="ident">iter_end</span> {
            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">data2</span>) <span class="op">=</span> <span class="ident">more_data</span> {
                <span class="kw">let</span> (<span class="kw">_</span>, <span class="ident">samples2</span>) <span class="op">=</span> <span class="kw">unsafe</span> {  <span class="ident">data2</span>.<span class="ident">write_samples</span>(<span class="ident">i</span>) };
                <span class="ident">z</span> <span class="op">+</span><span class="op">=</span> <span class="ident">samples2</span> <span class="op">/</span> <span class="ident">data2</span>.<span class="ident">channels</span> <span class="kw">as</span> <span class="ident">isize</span>;
            }
        }
        <span class="kw">let</span> <span class="ident">z</span> <span class="op">=</span> <span class="ident">z</span> <span class="kw">as</span> <span class="ident">Frames</span>;
        <span class="self">self</span>.<span class="ident">commit</span>(<span class="ident">z</span>);
        <span class="ident">z</span>
    }
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> <span class="ident">MmapCapture</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span> {
    <span class="doccomment">/// Read samples from the kernel ringbuffer.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// When the iterator is dropped or depleted, the read samples will be committed, i e,</span>
    <span class="doccomment">/// the kernel can then write data to the location again. So do this ASAP.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">iter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="self">self</span>) -&gt; <span class="ident">CaptureIter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">S</span><span class="op">&gt;</span> {
        <span class="kw">let</span> (<span class="ident">data</span>, <span class="ident">more_data</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">data_ptr</span>();
        <span class="ident">CaptureIter</span> {
            <span class="ident">m</span>: <span class="self">self</span>,
            <span class="ident">samples</span>: <span class="ident">data</span>,
            <span class="ident">p_offs</span>: <span class="number">0</span>,
            <span class="ident">read_samples</span>: <span class="number">0</span>,
            <span class="ident">next_p</span>: <span class="ident">more_data</span>,
        }
    }
}

<span class="doccomment">/// Iterator over captured samples</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">CaptureIter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">S</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> {
    <span class="ident">m</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">MmapCapture</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>,
    <span class="ident">samples</span>: <span class="ident">RawSamples</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>,
    <span class="ident">p_offs</span>: <span class="ident">isize</span>,
    <span class="ident">read_samples</span>: <span class="ident">isize</span>,
    <span class="ident">next_p</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">RawSamples</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">S</span>: <span class="lifetime">&#39;static</span> <span class="op">+</span> <span class="ident">Copy</span><span class="op">&gt;</span> <span class="ident">CaptureIter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">S</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">handle_max</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) {
        <span class="self">self</span>.<span class="ident">p_offs</span> <span class="op">=</span> <span class="number">0</span>;
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">p2</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">next_p</span>.<span class="ident">take</span>() {
            <span class="self">self</span>.<span class="ident">samples</span> <span class="op">=</span> <span class="ident">p2</span>;
        } <span class="kw">else</span> {
            <span class="self">self</span>.<span class="ident">m</span>.<span class="ident">commit</span>((<span class="self">self</span>.<span class="ident">read_samples</span> <span class="op">/</span> <span class="self">self</span>.<span class="ident">samples</span>.<span class="ident">channels</span> <span class="kw">as</span> <span class="ident">isize</span>) <span class="kw">as</span> <span class="ident">Frames</span>);
            <span class="self">self</span>.<span class="ident">read_samples</span> <span class="op">=</span> <span class="number">0</span>;
            <span class="self">self</span>.<span class="ident">samples</span>.<span class="ident">frames</span> <span class="op">=</span> <span class="number">0</span>; <span class="comment">// Shortcut to &quot;None&quot; in case anyone calls us again</span>
        }
    }
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">S</span>: <span class="lifetime">&#39;static</span> <span class="op">+</span> <span class="ident">Copy</span><span class="op">&gt;</span> <span class="ident">Iterator</span> <span class="kw">for</span> <span class="ident">CaptureIter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">S</span><span class="op">&gt;</span> {
    <span class="kw">type</span> <span class="ident">Item</span> <span class="op">=</span> <span class="ident">S</span>;

    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">next</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Item</span><span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">p_offs</span> <span class="op">&gt;</span><span class="op">=</span> <span class="self">self</span>.<span class="ident">samples</span>.<span class="ident">samples</span>() {
            <span class="self">self</span>.<span class="ident">handle_max</span>();
            <span class="kw">if</span> <span class="self">self</span>.<span class="ident">samples</span>.<span class="ident">frames</span> <span class="op">&lt;</span><span class="op">=</span> <span class="number">0</span> { <span class="kw">return</span> <span class="prelude-val">None</span>; }
        }
        <span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">ptr::read_volatile</span>(<span class="self">self</span>.<span class="ident">samples</span>.<span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="self">self</span>.<span class="ident">p_offs</span>)) };
        <span class="self">self</span>.<span class="ident">p_offs</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        <span class="self">self</span>.<span class="ident">read_samples</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        <span class="prelude-val">Some</span>(<span class="ident">s</span>)
    }
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">S</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> <span class="ident">Drop</span> <span class="kw">for</span> <span class="ident">CaptureIter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">S</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">drop</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) {
        <span class="self">self</span>.<span class="ident">m</span>.<span class="ident">commit</span>((<span class="self">self</span>.<span class="ident">read_samples</span> <span class="op">/</span> <span class="self">self</span>.<span class="ident">m</span>.<span class="ident">data</span>.<span class="ident">channels</span> <span class="kw">as</span> <span class="ident">isize</span>) <span class="kw">as</span> <span class="ident">Frames</span>);
    }
}


<span class="attribute">#[<span class="ident">test</span>]</span>
<span class="attribute">#[<span class="ident">ignore</span>]</span> <span class="comment">// Not everyone has a recording device on plughw:1. So let&#39;s ignore this test by default.</span>
<span class="kw">fn</span> <span class="ident">record_from_plughw_rw</span>() {
    <span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::pcm</span>::<span class="kw-2">*</span>;
    <span class="kw">use</span> <span class="kw">crate</span>::{<span class="ident">ValueOr</span>, <span class="ident">Direction</span>};
    <span class="kw">use</span> <span class="ident">std::ffi::CString</span>;
    <span class="kw">let</span> <span class="ident">pcm</span> <span class="op">=</span> <span class="ident">PCM::open</span>(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">CString::new</span>(<span class="string">&quot;plughw:1&quot;</span>).<span class="ident">unwrap</span>(), <span class="ident">Direction::Capture</span>, <span class="bool-val">false</span>).<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">ss</span> <span class="op">=</span> <span class="ident"><span class="self">self</span>::Status::new</span>(<span class="kw-2">&amp;</span><span class="ident">pcm</span>).<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident"><span class="self">self</span>::Control::new</span>(<span class="kw-2">&amp;</span><span class="ident">pcm</span>).<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">hwp</span> <span class="op">=</span> <span class="ident">HwParams::any</span>(<span class="kw-2">&amp;</span><span class="ident">pcm</span>).<span class="ident">unwrap</span>();
    <span class="ident">hwp</span>.<span class="ident">set_channels</span>(<span class="number">2</span>).<span class="ident">unwrap</span>();
    <span class="ident">hwp</span>.<span class="ident">set_rate</span>(<span class="number">44100</span>, <span class="ident">ValueOr::Nearest</span>).<span class="ident">unwrap</span>();
    <span class="ident">hwp</span>.<span class="ident">set_format</span>(<span class="ident">Format::s16</span>()).<span class="ident">unwrap</span>();
    <span class="ident">hwp</span>.<span class="ident">set_access</span>(<span class="ident">Access::RWInterleaved</span>).<span class="ident">unwrap</span>();
    <span class="ident">pcm</span>.<span class="ident">hw_params</span>(<span class="kw-2">&amp;</span><span class="ident">hwp</span>).<span class="ident">unwrap</span>();

    {
        <span class="kw">let</span> <span class="ident">swp</span> <span class="op">=</span> <span class="ident">pcm</span>.<span class="ident">sw_params_current</span>().<span class="ident">unwrap</span>();
        <span class="ident">swp</span>.<span class="ident">set_tstamp_mode</span>(<span class="bool-val">true</span>).<span class="ident">unwrap</span>();
        <span class="ident">pcm</span>.<span class="ident">sw_params</span>(<span class="kw-2">&amp;</span><span class="ident">swp</span>).<span class="ident">unwrap</span>();
    }
    <span class="macro">assert_eq!</span>(<span class="ident">ss</span>.<span class="ident">state</span>(), <span class="ident">State::Prepared</span>);
    <span class="ident">pcm</span>.<span class="ident">start</span>().<span class="ident">unwrap</span>();
    <span class="macro">assert_eq!</span>(<span class="ident">c</span>.<span class="ident">appl_ptr</span>(), <span class="number">0</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{:?}, {:?}&quot;</span>, <span class="ident">ss</span>, <span class="ident">c</span>);
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> [<span class="number">0i16</span>; <span class="number">512</span><span class="kw-2">*</span><span class="number">2</span>];
    <span class="macro">assert_eq!</span>(<span class="ident">pcm</span>.<span class="ident">io_i16</span>().<span class="ident">unwrap</span>().<span class="ident">readi</span>(<span class="kw-2">&amp;mut</span> <span class="ident">buf</span>).<span class="ident">unwrap</span>(), <span class="number">512</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">c</span>.<span class="ident">appl_ptr</span>(), <span class="number">512</span>);

    <span class="macro">assert_eq!</span>(<span class="ident">ss</span>.<span class="ident">state</span>(), <span class="ident">State::Running</span>);
    <span class="macro">assert!</span>(<span class="ident">ss</span>.<span class="ident">hw_ptr</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">512</span>);
    <span class="kw">let</span> <span class="ident">t2</span> <span class="op">=</span> <span class="ident">ss</span>.<span class="ident">htstamp</span>();
    <span class="macro">assert!</span>(<span class="ident">t2</span>.<span class="ident">tv_sec</span> <span class="op">&gt;</span> <span class="number">0</span> <span class="op">|</span><span class="op">|</span> <span class="ident">t2</span>.<span class="ident">tv_nsec</span> <span class="op">&gt;</span> <span class="number">0</span>);
}


<span class="attribute">#[<span class="ident">test</span>]</span>
<span class="attribute">#[<span class="ident">ignore</span>]</span> <span class="comment">// Not everyone has a record device on plughw:1. So let&#39;s ignore this test by default.</span>
<span class="kw">fn</span> <span class="ident">record_from_plughw_mmap</span>() {
    <span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::pcm</span>::<span class="kw-2">*</span>;
    <span class="kw">use</span> <span class="kw">crate</span>::{<span class="ident">ValueOr</span>, <span class="ident">Direction</span>};
    <span class="kw">use</span> <span class="ident">std::ffi::CString</span>;
    <span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">thread</span>, <span class="ident">time</span>};

    <span class="kw">let</span> <span class="ident">pcm</span> <span class="op">=</span> <span class="ident">PCM::open</span>(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">CString::new</span>(<span class="string">&quot;plughw:1&quot;</span>).<span class="ident">unwrap</span>(), <span class="ident">Direction::Capture</span>, <span class="bool-val">false</span>).<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">hwp</span> <span class="op">=</span> <span class="ident">HwParams::any</span>(<span class="kw-2">&amp;</span><span class="ident">pcm</span>).<span class="ident">unwrap</span>();
    <span class="ident">hwp</span>.<span class="ident">set_channels</span>(<span class="number">2</span>).<span class="ident">unwrap</span>();
    <span class="ident">hwp</span>.<span class="ident">set_rate</span>(<span class="number">44100</span>, <span class="ident">ValueOr::Nearest</span>).<span class="ident">unwrap</span>();
    <span class="ident">hwp</span>.<span class="ident">set_format</span>(<span class="ident">Format::s16</span>()).<span class="ident">unwrap</span>();
    <span class="ident">hwp</span>.<span class="ident">set_access</span>(<span class="ident">Access::MMapInterleaved</span>).<span class="ident">unwrap</span>();
    <span class="ident">pcm</span>.<span class="ident">hw_params</span>(<span class="kw-2">&amp;</span><span class="ident">hwp</span>).<span class="ident">unwrap</span>();

    <span class="kw">let</span> <span class="ident">ss</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">SyncPtrStatus::sync_ptr</span>(<span class="ident">pcm_to_fd</span>(<span class="kw-2">&amp;</span><span class="ident">pcm</span>).<span class="ident">unwrap</span>(), <span class="bool-val">false</span>, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>).<span class="ident">unwrap</span>() };
    <span class="macro">assert_eq!</span>(<span class="ident">ss</span>.<span class="ident">state</span>(), <span class="ident">State::Prepared</span>);

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">m</span> <span class="op">=</span> <span class="ident">pcm</span>.<span class="ident">direct_mmap_capture</span>::<span class="op">&lt;</span><span class="ident">i16</span><span class="op">&gt;</span>().<span class="ident">unwrap</span>();

    <span class="macro">assert_eq!</span>(<span class="ident">m</span>.<span class="ident">status</span>().<span class="ident">state</span>(), <span class="ident">State::Prepared</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">m</span>.<span class="ident">appl_ptr</span>(), <span class="number">0</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">m</span>.<span class="ident">hw_ptr</span>(), <span class="number">0</span>);


    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">m</span>);

    <span class="kw">let</span> <span class="ident">now</span> <span class="op">=</span> <span class="ident">time::Instant::now</span>();
    <span class="ident">pcm</span>.<span class="ident">start</span>().<span class="ident">unwrap</span>();
    <span class="kw">while</span> <span class="ident">m</span>.<span class="ident">avail</span>() <span class="op">&lt;</span> <span class="number">256</span> { <span class="ident">thread::sleep</span>(<span class="ident">time::Duration::from_millis</span>(<span class="number">1</span>)) };
    <span class="macro">assert!</span>(<span class="ident">now</span>.<span class="ident">elapsed</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="ident">time::Duration::from_millis</span>(<span class="number">256</span> <span class="op">*</span> <span class="number">1000</span> <span class="op">/</span> <span class="number">44100</span>));
    <span class="kw">let</span> (<span class="ident">ptr1</span>, <span class="ident">md</span>) <span class="op">=</span> <span class="ident">m</span>.<span class="ident">data_ptr</span>();
    <span class="macro">assert_eq!</span>(<span class="ident">ptr1</span>.<span class="ident">channels</span>, <span class="number">2</span>);
    <span class="macro">assert!</span>(<span class="ident">ptr1</span>.<span class="ident">frames</span> <span class="op">&gt;</span><span class="op">=</span> <span class="number">256</span>);
    <span class="macro">assert!</span>(<span class="ident">md</span>.<span class="ident">is_none</span>());
    <span class="macro">println!</span>(<span class="string">&quot;Has {:?} frames at {:?} in {:?}&quot;</span>, <span class="ident">m</span>.<span class="ident">avail</span>(), <span class="ident">ptr1</span>.<span class="ident">ptr</span>, <span class="ident">now</span>.<span class="ident">elapsed</span>());
    <span class="kw">let</span> <span class="ident">samples</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i16</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">m</span>.<span class="ident">iter</span>().<span class="ident">collect</span>();
    <span class="macro">assert!</span>(<span class="ident">samples</span>.<span class="ident">len</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="ident">ptr1</span>.<span class="ident">frames</span> <span class="kw">as</span> <span class="ident">usize</span> <span class="op">*</span> <span class="number">2</span>);
    <span class="macro">println!</span>(<span class="string">&quot;Collected {} samples&quot;</span>, <span class="ident">samples</span>.<span class="ident">len</span>());
    <span class="kw">let</span> (<span class="ident">ptr2</span>, <span class="ident">_md</span>) <span class="op">=</span> <span class="ident">m</span>.<span class="ident">data_ptr</span>();
    <span class="macro">assert!</span>(<span class="kw">unsafe</span> { <span class="ident">ptr1</span>.<span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="number">256</span> <span class="op">*</span> <span class="number">2</span>) } <span class="op">&lt;</span><span class="op">=</span> <span class="ident">ptr2</span>.<span class="ident">ptr</span>);
}

<span class="attribute">#[<span class="ident">test</span>]</span>
<span class="attribute">#[<span class="ident">ignore</span>]</span>
<span class="kw">fn</span> <span class="ident">playback_to_plughw_mmap</span>() {
    <span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::pcm</span>::<span class="kw-2">*</span>;
    <span class="kw">use</span> <span class="kw">crate</span>::{<span class="ident">ValueOr</span>, <span class="ident">Direction</span>};
    <span class="kw">use</span> <span class="ident">std::ffi::CString</span>;

    <span class="kw">let</span> <span class="ident">pcm</span> <span class="op">=</span> <span class="ident">PCM::open</span>(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">CString::new</span>(<span class="string">&quot;plughw:1&quot;</span>).<span class="ident">unwrap</span>(), <span class="ident">Direction::Playback</span>, <span class="bool-val">false</span>).<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">hwp</span> <span class="op">=</span> <span class="ident">HwParams::any</span>(<span class="kw-2">&amp;</span><span class="ident">pcm</span>).<span class="ident">unwrap</span>();
    <span class="ident">hwp</span>.<span class="ident">set_channels</span>(<span class="number">2</span>).<span class="ident">unwrap</span>();
    <span class="ident">hwp</span>.<span class="ident">set_rate</span>(<span class="number">44100</span>, <span class="ident">ValueOr::Nearest</span>).<span class="ident">unwrap</span>();
    <span class="ident">hwp</span>.<span class="ident">set_format</span>(<span class="ident">Format::s16</span>()).<span class="ident">unwrap</span>();
    <span class="ident">hwp</span>.<span class="ident">set_access</span>(<span class="ident">Access::MMapInterleaved</span>).<span class="ident">unwrap</span>();
    <span class="ident">pcm</span>.<span class="ident">hw_params</span>(<span class="kw-2">&amp;</span><span class="ident">hwp</span>).<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">m</span> <span class="op">=</span> <span class="ident">pcm</span>.<span class="ident">direct_mmap_playback</span>::<span class="op">&lt;</span><span class="ident">i16</span><span class="op">&gt;</span>().<span class="ident">unwrap</span>();

    <span class="macro">assert_eq!</span>(<span class="ident">m</span>.<span class="ident">status</span>().<span class="ident">state</span>(), <span class="ident">State::Prepared</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">m</span>.<span class="ident">appl_ptr</span>(), <span class="number">0</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">m</span>.<span class="ident">hw_ptr</span>(), <span class="number">0</span>);

    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">m</span>);
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">i</span> <span class="op">=</span> (<span class="number">0</span>..(<span class="ident">m</span>.<span class="ident">buffer_size</span>() <span class="op">*</span> <span class="number">2</span>)).<span class="ident">map</span>(<span class="op">|</span><span class="ident">i</span><span class="op">|</span>
        (((<span class="ident">i</span> <span class="op">/</span> <span class="number">2</span>) <span class="kw">as</span> <span class="ident">f32</span> <span class="op">*</span> <span class="number">2.0</span> <span class="op">*</span> <span class="ident">::std::f32::consts::PI</span> <span class="op">/</span> <span class="number">128.0</span>).<span class="ident">sin</span>() <span class="op">*</span> <span class="number">8192.0</span>) <span class="kw">as</span> <span class="ident">i16</span>);
    <span class="ident">m</span>.<span class="ident">write</span>(<span class="kw-2">&amp;mut</span> <span class="ident">i</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">m</span>.<span class="ident">appl_ptr</span>(), <span class="ident">m</span>.<span class="ident">buffer_size</span>());

    <span class="ident">pcm</span>.<span class="ident">start</span>().<span class="ident">unwrap</span>();
    <span class="ident">pcm</span>.<span class="ident">drain</span>().<span class="ident">unwrap</span>();
    <span class="macro">assert_eq!</span>(<span class="ident">m</span>.<span class="ident">appl_ptr</span>(), <span class="ident">m</span>.<span class="ident">buffer_size</span>());
    <span class="macro">assert!</span>(<span class="ident">m</span>.<span class="ident">hw_ptr</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="ident">m</span>.<span class="ident">buffer_size</span>());
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="alsa" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.62.0 (a8314ef7d 2022-06-27)" ></div>
</body></html>